<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>The Official Radare Blog  | Emulating a simple bootloader</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.58.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="Emulating a simple bootloader" />
<meta property="og:description" content="Introduction Generally speaking, emulating a bootloader is simpler than it is for regular binaries, because they lack external libraries and usually have direct access to memory and hardware.
In this case, the bootloader is a binary for x86 architecture which runs in 16-bits real mode using BIOS calls to perform its loading duties and textual input/output.
The idea here is to emulate Cropta1 crackme using radare2 ESIL emulation, providing the needed BIOS via a trivial quick &amp; dirty python implementation of just what it&rsquo;s needed to run the crackme code." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://radare.today/posts/emulating-simple-bootloader/" />
<meta property="article:published_time" content="2016-08-16T19:16:00+02:00" />
<meta property="article:modified_time" content="2016-08-16T19:16:00+02:00" />
<meta itemprop="name" content="Emulating a simple bootloader">
<meta itemprop="description" content="Introduction Generally speaking, emulating a bootloader is simpler than it is for regular binaries, because they lack external libraries and usually have direct access to memory and hardware.
In this case, the bootloader is a binary for x86 architecture which runs in 16-bits real mode using BIOS calls to perform its loading duties and textual input/output.
The idea here is to emulate Cropta1 crackme using radare2 ESIL emulation, providing the needed BIOS via a trivial quick &amp; dirty python implementation of just what it&rsquo;s needed to run the crackme code.">


<meta itemprop="datePublished" content="2016-08-16T19:16:00&#43;02:00" />
<meta itemprop="dateModified" content="2016-08-16T19:16:00&#43;02:00" />
<meta itemprop="wordCount" content="1851">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Emulating a simple bootloader"/>
<meta name="twitter:description" content="Introduction Generally speaking, emulating a bootloader is simpler than it is for regular binaries, because they lack external libraries and usually have direct access to memory and hardware.
In this case, the bootloader is a binary for x86 architecture which runs in 16-bits real mode using BIOS calls to perform its loading duties and textual input/output.
The idea here is to emulate Cropta1 crackme using radare2 ESIL emulation, providing the needed BIOS via a trivial quick &amp; dirty python implementation of just what it&rsquo;s needed to run the crackme code."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://radare.today" class="f3 fw2 hover-white no-underline white-90 dib">
      The Official Radare Blog
    </a>
    <div class="flex-l items-center">
      

      
      



<a href="radareorg" target="_blank" class="link-transition twitter link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel="noopener" aria-label="follow on Twitter——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Emulating a simple bootloader</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2016-08-16T19:16:00&#43;02:00">August 16, 2016</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h2 id="introduction">Introduction</h2>

<p>Generally speaking, emulating a bootloader is simpler than it is for regular binaries, because they lack external libraries and usually have direct access to memory and hardware.</p>

<p>In this case, the bootloader is a binary for x86 architecture which runs in 16-bits real mode using <a href="http://www.ctyme.com/intr/int.htm">BIOS calls</a> to perform its loading duties and textual input/output.</p>

<p>The idea here is to emulate <a href="http://crackmes.de/users/cropta/cropta_1/">Cropta1 crackme</a> using radare2 ESIL emulation, providing the needed BIOS via a trivial quick &amp; dirty python implementation of just what it&rsquo;s needed to run the crackme code.</p>

<p>There are several ways to do it, I tried two of them and here is the story.</p>

<h2 id="take-one-use-r2pipe">Take one, use r2pipe</h2>

<p>Whenever i use r2pipe i feel home, moreover there&rsquo;s an example (in nodejs) of a similar case - <a href="https://github.com/radare/radare2-bindings/tree/master/r2pipe/nodejs/examples/syscall">the emulation of syscalls</a> - that&rsquo;s why it&rsquo;s the first thing i tried.</p>

<p>My bios looked like this:</p>

<pre><code class="language-python">import r2pipe, sys, os

r2 = r2pipe.open('#!pipe')

# just the hdd params stolen from bochsrc
cylinders=20
heads=16
spt=63
bps=512

# function to read a key from stdin
def wait_key():
	result = None
	if os.name == 'nt':
		import msvcrt
		result = msvcrt.getch()
	else:
		import termios
		fd = sys.stdin.fileno()
		oldterm = termios.tcgetattr(fd)
		newattr = termios.tcgetattr(fd)
		newattr[3] = newattr[3] &amp; ~termios.ICANON &amp; ~termios.ECHO
		termios.tcsetattr(fd, termios.TCSANOW, newattr)
		try:
			result = sys.stdin.read(1)
		except:
			pass
		finally:
			termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
		return result


# this handles the interrupts
def handle_intr(intNum):
	regs = r2.cmdj('arj')

	# helper funcs to read/write hi and low parts of regs
	def xh(regName, setValue = None):
		val = regs[regName]
		if setValue == None:
			return (val &amp; 0xff00)&gt;&gt;8
		else:
			val = (val &amp; 0xff) | ((setValue &amp; 0xff) &lt;&lt; 8)
			r2.cmd('ar ' + regName + '=' + hex(val))
			return val

	def xl(regName, setValue = None):
		val = regs[regName]
		if setValue == None:
			return val &amp; 0xff
		else:
			val = (val &amp; 0xff00) | (setValue &amp; 0xff)
			r2.cmd('ar ' + regName + '=' + hex(val))
			return val

	# command is in ah
	command = xh('ax') 

	# read/write disk
	if intNum == 0x13: 
		# read from disk to memory
		if command == 2:
			# al, number of sectors to read
			nSectors = xl('ax')
			
			# ch, cylinder
			cylinder = xh('cx')
			
			# cl, sector
			firstSector = xl('cx')
			
			# dh, head
			head = xh('dx') 
			
			# bx, buffer in memory
			destination = regs['bx'] &amp; 0xffff

			# hdd math
			source = (firstSector - 1 + (head + cylinder * heads) * spt ) * bps
			length = nSectors * bps

			# do the actual writing in r2
			r2.cmd('e io.cache=true')
			r2.cmd('wd ' + hex(source) + ' ' + hex(length) + ' @ ' + hex(destination))
			
			# success -&gt; carry flag = 0
			r2.cmd('ar cf=0')
		
		# geometry query
		elif command == 8: 
			# dl drive number
			driveNum = xl('dx')
			
			if driveNum != 0x80:
				# if not first drive, error -&gt; carry flag = 1
				r2.cmd('ar cf=1')
			else:
				# success, return geometry
				r2.cmd('ar cf=0')
				r2.cmd('ar ax=0')
				r2.cmd('ar dx=' + hex(((heads-1) &lt;&lt; 8) | 1))
				r2.cmd('ar cx=' + hex(spt | (cylinders &lt;&lt; 8)))

	# keyboard i/o
	elif intNum == 0x16: 
		# read extended key
		if command == 0x10:
			result = ord(wait_key())
			high = 0
			if result == 10:
				high = 0x1c
			elif result == 127:
				high = 0xe
			r2.cmd('ar ax=' + hex(result | (high &lt;&lt; 8)))

	# screen output
	elif intNum == 0x10:
		# print char
		if command == 0xe:
			char = chr(xl('ax'))
			sys.stdout.write(char)
			sys.stdout.flush()

# call it, with parameter coming from r2
handle_intr(int(sys.argv[1], 0))
</code></pre>

<p>The above code is far from being a complete BIOS implementation, or even to be a correct subset: it&rsquo;s just what the crackme uses in its interesting part - the initial.</p>

<p>Running this in radare2 is as easy as doing:</p>

<pre><code class="language-r2">$ r2 -b 16 HardDisk
 -- Choose your architecture by typing: 'e asm.arch=&lt;arch&gt;'
[0000:0000]&gt; aei
[0000:0000]&gt; aeim 0x2000 0xffff
[0000:0000]&gt; aeip
[0000:0000]&gt; e io.cache=true
[0000:0000]&gt; &quot;e cmd.esil.intr=#!pipe python bios_pipe.py&quot;
[0000:0000]&gt; e esil.gotolimit=0xffff
[0000:0000]&gt; ! (sleep 30 &amp;&amp; killall -3 r2)&amp;
[0000:0000]&gt; aec
</code></pre>

<p>The following paragraph (Emulation setup) is an explosion of the above r2 commands with a lengthy explanation of each, feel free to skip it if the above r2 passage is obvious to you.</p>

<h3 id="emulation-setup">Emulation setup</h3>

<p>&ndash;</p>

<pre><code class="language-r2">[0000:0000]&gt; aei
</code></pre>

<p><code>aei</code> initializes the ESIL VM state (as stated in <code>ae?</code> help) which means if there was a previous ESIL context is destroyed here and a new ESIL stack gets deployed.</p>

<p>&ndash;</p>

<pre><code class="language-r2">[0000:0000]&gt; aeim 0x2000 0xffff
</code></pre>

<p><code>aeim</code> allocates the memory for mem read / write operations, basically needed for the stack pointer to point somewhere harmless.</p>

<p>Here i&rsquo;m placing the start of it at address <code>0x2000</code> with a length of <code>0xffff</code> bytes. The value for the start value is exactly the size of the binary, so that memory writes will likely not overwrite the code.</p>

<p>At the beginning of the bootloader code the stack pointer is placed at address <code>0x7c00</code>, so it can grow for <code>23552</code> bytes before potentially overlapping to the code. It may or may not be enough, hopefully it is for this simple case.</p>

<p>In more complex cases of boot loader, maybe it&rsquo;s necessary to keep the memory in one file descriptor and the code in another. This is possible for example by using temporary file descriptor seeks in r2 read / write commands.</p>

<p>&ndash;</p>

<pre><code class="language-r2">[0000:0000]&gt; aeip
</code></pre>

<p>This will set the ESIL instruction pointer (and the IP alias register of the current architecture, as specified in the register profile of the anal plugin) to the current seek, namely <code>0</code>.</p>

<p>&ndash;</p>

<pre><code class="language-r2">[0000:0000]&gt; e io.cache=true
</code></pre>

<p>This let us write in the current session&rsquo;s memory without having r2 to write it back to the binary file.</p>

<p>&ndash;</p>

<pre><code class="language-r2">[0000:0000]&gt; &quot;e cmd.esil.intr=#!pipe python bios_pipe.py&quot;
</code></pre>

<p>This, in pseudo english, means: &ldquo;Every time there&rsquo;s an ESIL interrupt (<code>$</code> instruction), spawn this python script and pass it the number of the interrupt as argument&rdquo;. This will load and execute the bios depicted above.</p>

<p>&ndash;</p>

<pre><code class="language-r2">[0000:0000]&gt; e esil.gotolimit=0xffff
</code></pre>

<p>This one. It took me a couple of hours to figure out what that <code>ESIL infinite loop detected</code> error message did mean.</p>

<p>The failing instruction was: <code>rep movsb byte es:[di], byte ptr [si]</code> which is known to be bounded by the <code>cx</code> value, which was itself conveniently set to the very finite value of <code>0x1e5</code> just few bytes above&hellip; so?</p>

<p>It turns out that the <code>gotolimit</code> is the maximum allowed count of single ESIL instructions which can be executed in a statement - and that&rsquo;s great. In this case, the esil statement for the above failing instruction is:</p>

<pre><code class="language-esil">cx,!,?{,BREAK,},si,[1],di,=[1],df,?{,1,si,-=,1,di,-=,},df,!,?{,1,si,+=,1,di,+=,},cx,--=,cx,?{,5,GOTO,}
</code></pre>

<p>which is composed by <code>35</code> esil instructions, so doing the rough math <code>?v 35*0x1e5</code> = <code>0x424f</code> which is clearly greater than the default <code>esil.gotolimit = 0x00001000</code> even if we ignore the fact that the <code>GOTO</code> jumps to instruction 5 and not to the beginning of the statement.</p>

<p>&ndash;</p>

<pre><code class="language-r2">[0000:0000]&gt; ! (sleep 30 &amp;&amp; killall -3 r2)&amp;
</code></pre>

<p>At the end of the emulated code, the bootloader code enters an infinite loop. This is a dirty trick to schedule r2 quit at 30 seconds from now whatever happens (included that you may have closed an r2 session and opened another one in the meantime&hellip;).</p>

<p>This particular one needs a posix shell to work.</p>

<p>&ndash;</p>

<pre><code class="language-r2">[0000:0000]&gt; aec
</code></pre>

<p>Starts the emulation until CTRL+C is pressed, if you have a chance to, if CTRL+C is honored by both radare2 and the spawned python code which may be running continuously at that time. Basically, in this case, it means run the emulation forever (due to the final infinite loop) or until r2 is killed by the dirty trick above.</p>

<h3 id="cinema-of-take-one">Cinema of take one</h3>

<p><a href="https://asciinema.org/a/88nezce35db4uo28qvlk4y5vc"><img src="https://asciinema.org/a/88nezce35db4uo28qvlk4y5vc.png" alt="asciicast" /></a></p>

<p>This demonstration shows all the above actually works, but - unless you&rsquo;re shooting an 1980s sci-fi B-movie - it&rsquo;s spectacularly slow for every real world use case.</p>

<h2 id="take-two-using-r2lang-python-rcore-plugin">Take two, using r2lang + python RCore plugin</h2>

<p>At that point, also after talking to pancake about this, there could be several reasons for it to be so slow, sorted by probability (more probable first):</p>

<ul>
<li>spawning python intepreter at each interrupt is slow</li>
<li>my shitty python code is slow</li>
<li>python in general is slow</li>
<li>ESIL emulation is slow</li>
</ul>

<p>Starting to address the more probable issue, an alternative way to do this - while still using my python BIOS - is to define an RCore plugin which accepts a new &lsquo;bios&rsquo; command. In this way the python code is loaded only once and then at each interrupt the command itself gets executed, reusing the same python context.</p>

<p>Here is the modifications to the python code above:</p>

<p>1 - instead of importing <code>r2pipe</code>, let&rsquo;s import <code>r2lang</code>:</p>

<pre><code class="language-python">import r2lang, sys, os, json
r2 = r2lang
</code></pre>

<p>2 - replace missing <code>cmdj</code> with native python <code>json.loads</code> in bios code:</p>

<pre><code class="language-python"># this handles the interrupts
def handle_intr(intNum):
	regs = json.loads(r2.cmd('arj'))
	...
</code></pre>

<p>3 - register the core plugin:</p>

<pre><code class="language-python">def bioscore(a):
	def _call(s):
		if s == &quot;bios&quot;:
			ip = int(r2.cmd(&quot;ar ip&quot;),0) - 2
			num = int(r2.cmd(&quot;?v $v@&quot; + hex(ip)),0)
			handle_intr(num)
			return 1
		return 0

	return {
		&quot;name&quot; : &quot;BiosCore&quot;,
		&quot;license&quot;: &quot;WTFPL&quot;,
		&quot;desc&quot;: &quot;toy bios&quot;,
		&quot;call&quot;: _call
	}


r2lang.plugin(&quot;core&quot;, bioscore)
</code></pre>

<p>The most evident issue so far is that the custom commands defined in RCore plugins don&rsquo;t accept parameters, therefore here is another dirty trick.</p>

<p>In order to get the numeric value of the interrupt, i decided to use the <code>$v</code> variable which returns the immediate value of the instruction at the current seek. The problem here is that during emulation, the instruction pointer has been already incremented by the time the interrupt gets executed. So, assuming that x86 16-bit encoding of <code>INT XX</code> instructions is always 2 bytes long, i just subtracted <code>2</code> to current <code>ip</code> value in order to get the seek for the immediate value to extract.</p>

<p>And again, the execution sequence:</p>

<pre><code class="language-r2">$ r2 -i bios.py -b 16 HardDisk
 -- You are probably using an old version of r2, go checkout the git!
[0000:0000]&gt; aei
[0000:0000]&gt; aeim 0x2000 0xffff
[0000:0000]&gt; aeip
[0000:0000]&gt; e io.cache=true
[0000:0000]&gt; (orpo, bios)
[0000:0000]&gt; &quot;e cmd.esil.intr=` `;.(orpo)&quot;
[0000:0000]&gt; e esil.gotolimit=0xffff
[0000:0000]&gt; ! (sleep 30 &amp;&amp; killall -3 r2)&amp;
[0000:0000]&gt; aec
</code></pre>

<h3 id="emulation-setup-differences">Emulation setup (differences)</h3>

<p>&ndash;</p>

<pre><code class="language-r2">[0000:0000]&gt; (orpo, bios)
</code></pre>

<p>Again, custom commands do not accept parameters. More: if they&rsquo;re called with a parameter, they don&rsquo;t get executed at all.</p>

<p>To overcome this limitation, i just defined a macro named <code>orpo</code>. In this way, the extra unusable parameter which r2 pass to the <code>intr</code> handler is just ignored and the custom command is called.</p>

<p>&ndash;</p>

<pre><code class="language-r2">[0000:0000]&gt; &quot;e cmd.esil.intr=` `;.(orpo)&quot;
</code></pre>

<p>Here is the modified <code>intr</code> handler which in turn calls our macro, which in turn calls our custom command.</p>

<p>Buried in the above command line there&rsquo;s also another mystery i lost an interesting hour to workaround. That space in backticks. By removing that, each char which is output from my BIOS command gets prepended by what it seems the output of a <code>printf(&quot;0x%x\n&quot;, somevalue);</code> buried somewhere along the r2 code path around the interrupt handling / r2lang io piping (i guess, but actually i was unable to find it).</p>

<h3 id="cinema-of-take-two">Cinema of take two</h3>

<p><a href="https://asciinema.org/a/6q6cvq2i1xdwsjrq2o5we4vad"><img src="https://asciinema.org/a/6q6cvq2i1xdwsjrq2o5we4vad.png" alt="asciicast" /></a></p>

<p>Hey! This time is faster. Still there&rsquo;s space for improvements, i guess it&rsquo;s possible to go down the list of slowdown probability unrolled above until rewriting the BIOS in C, for example. Honestly enough, though, the python RCore plugin seems pretty fast to me.</p>

<p>(by mrmacete)</p>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://radare.today" >
    &copy; 2019 The Official Radare Blog
  </a>
    <div>



<a href="radareorg" target="_blank" class="link-transition twitter link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel="noopener" aria-label="follow on Twitter——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
